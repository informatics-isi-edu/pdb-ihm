#!/usr/bin/python3
# 
# Copyright 2017 University of Southern California
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
Client for generating pyramidal tiles.
"""

import os
import subprocess
import json
from urllib.parse import urlparse
import sys
import traceback
import time
import shutil
import hashlib
import smtplib
from email.mime.text import MIMEText
import socket
import czifile
from dateutil.parser import parse
from .bioformats import BioformatsClient
from lxml.etree import XMLSyntaxError
from lxml import etree
from socket import gaierror, EAI_AGAIN

from deriva.core import PollingErmrestCatalog, HatracStore, urlquote

mail_footer = 'Do not reply to this message.  This is an automated message generated by the system, which does not receive email messages.'

class PyramidalClient (object):
    """Network client for generating pyramidal tiles.
    """
    ## Derived from the ermrest iobox service client

    def __init__(self, **kwargs):
        self.metadata = kwargs.get("metadata")
        self.baseuri = kwargs.get("baseuri")
        o = urlparse(self.baseuri)
        self.scheme = o[0]
        host_port = o[1].split(":")
        self.host = host_port[0]
        self.path = o.path
        self.port = None
        if len(host_port) > 1:
            self.port = host_port[1]
        self.dzi = kwargs.get("dzi")
        self.thumbnails = kwargs.get("thumbnails")
        self.czi2dzi = kwargs.get("czi2dzi")
        self.viewer = kwargs.get("viewer")
        self.czirules = kwargs.get("czirules")
        self.showinf = kwargs.get("showinf")
        self.data_scratch = kwargs.get("data_scratch")
        self.cookie = kwargs.get("cookie")
        self.store = HatracStore(
            self.scheme, 
            self.host,
            {'cookie': self.cookie}
        )
        self.catalog = PollingErmrestCatalog(
            self.scheme, 
            self.host,
            self.path.split('/')[-1],
            {'cookie': self.cookie}
        )
        self.catalog.dcctx['cid'] = 'pipeline/image/2D/czi'
        self.bftools_dirname = os.path.dirname(self.showinf)
        self.mail_server = kwargs.get("mail_server")
        self.mail_sender = kwargs.get("mail_sender")
        self.mail_receiver = kwargs.get("mail_receiver")
        self.logger = kwargs.get("logger")
        self.logger.debug('Client initialized.')

    """
    Send email notification
    """
    def sendMail(self, subject, text):
        if self.mail_server and self.mail_sender and self.mail_receiver:
            retry = 0
            ready = False
            while not ready:
                try:
                    msg = MIMEText('%s\n\n%s' % (text, mail_footer), 'plain')
                    msg['Subject'] = subject
                    msg['From'] = self.mail_sender
                    msg['To'] = self.mail_receiver
                    s = smtplib.SMTP(self.mail_server)
                    s.sendmail(self.mail_sender, self.mail_receiver.split(','), msg.as_string())
                    s.quit()
                    self.logger.debug('Sent email notification.')
                    ready = True
                except socket.gaierror as e:
                    if e.errno == socket.EAI_AGAIN:
                        time.sleep(100)
                        retry = retry + 1
                        ready = retry > 10
                    else:
                        ready = True
                    if ready:
                        et, ev, tb = sys.exc_info()
                        self.logger.error('got exception "%s"' % str(ev))
                        self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                except:
                    et, ev, tb = sys.exc_info()
                    self.logger.error('got exception "%s"' % str(ev))
                    self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
                    ready = True

    """
    Start the process for generating pyramidal tiles
    """
    def start(self):
        try:
            rid = os.getenv('RID', None)
            if rid == None:
                self.logger.error('RID was not specified in the environment')
                return
            
            action = os.getenv('action', None)
            if action == None:
                self.logger.error('"action" was not specified in the environment')
                return
                
            if action == 'histological_images_he_slide':
                self.processCZI('Histological_Images','HE_Slide', rid)
            elif action == 'immunofluorescence_slide':
                self.processCZI('Immunofluorescence', 'Slide', rid)
            elif action == 'gene_expression_image':
                self.processCZI('Gene_Expression', 'Image', rid, thumbnail=False)
            else:
                self.logger.error('Unknown action: "%s".' % action)
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: unexpected exception', '%s\nThe process might have been stopped\n' % ''.join(traceback.format_exception(et, ev, tb)))
            raise
        
    def processCZI(self, schema, table, rid, status='in progress', thumbnail=True):
        """
        Query for detecting the image to be processed
        """
        url = '/entity/%s:%s/RID=%s/Processing_Status=%s' % (urlquote(schema), urlquote(table), urlquote(rid), urlquote(status))
        self.logger.debug('Query URL: "%s"' % url) 
        
        resp = self.catalog.get(url)
        resp.raise_for_status()
        row = resp.json()[0]
        filename = row['Original_File_Name']
        file_url = row['Original_File_URL']
        creation_time = row['RCT']
        md5 = row['Original_File_MD5']
        
        consortium = row['Consortium']
        if consortium == 'RBK':
            waterMark = '&waterMark=\'Rebuildingakidney.org\''
        elif consortium == 'GUDMAP':
            waterMark = '&waterMark=\'GUDMAP.org\''
        else:
            waterMark = ''
        
        waterMark = ''
        thumbnail_url = row['Thumbnail_URL']
        
        if thumbnail == True:
            thumbnail_url = '/thumbnails/generic/generic_genetic.png'
        
        """
        Extract the file from hatrac
        """
        f = self.getHatracFile(filename, file_url)
        
        if f == None:
            return
        
        if md5 == None:
            md5 = self.md5hex(f)
            self.logger.debug("The MD5 was computed and it is: %s" % md5)
            
        """
        Create the directory for the tiles
        """
        year = parse(creation_time).strftime("%Y")
        outdir = '%s/%s/%s/%s' % (self.dzi, schema, year, md5)
        if not os.path.exists(outdir):
            os.makedirs(outdir)
        
        """
        Convert the file to DZI
        """
        returncode = self.convert2dzi(f, outdir)
        
        if returncode != 0:
            """
            Update the slide table with the failure result.
            """
            self.updateAttributes(schema,
                                  table,
                                  rid,
                                  ["Processing_Status"],
                                  {'RID': rid,
                                  'Processing_Status': 'error'
                                  },
                                  status)
            return
        
        if thumbnail == True:
            """
            Generate the thumbnail
            """
            thumbnail_url = self.writeThumbnailImage(schema, f, year, md5)
            
            if thumbnail_url == None:
                thumbnail_url = '/thumbnails/generic/generic_genetic.png'
                """
                Update the image table with the failure result.
                """
                self.updateAttributes(schema,
                                     table,
                                     rid,
                                     ["Thumbnail_URL", "Processing_Status"],
                                     {'RID': rid,
                                      'Thumbnail_URL': thumbnail_url,
                                      'Processing_Status': 'error'
                                     },
                                     status)
                return
                
        """
        Get the viewer URI
        """
        urls = self.getPyramidURL(schema, f, year, md5, waterMark)
        if urls == None:
            """
            Update the image table with the failure result.
            """
            self.updateAttributes(schema,
                                 table,
                                 rid,
                                 ["Thumbnail_URL", "Processing_Status"],
                                 {'RID': rid,
                                  'Thumbnail_URL': thumbnail_url,
                                  'Processing_Status': 'error'
                                 },
                                 status)
            return
            
        """
        Extract the metadata
        """
        self.logger.debug('Extracting metadata for filename "%s"' % (filename)) 
        bioformatsClient = BioformatsClient(showinf=self.showinf, \
                                            czirules=self.czirules, \
                                            cziFile=f, \
                                            logger=self.logger)
        try:
            metadata = bioformatsClient.getMetadata()
            if metadata == None:
                metadata = {}
            self.logger.debug('Metadata: "%s"' % str(metadata)) 
            os.remove('%s/temp.xml' % self.bftools_dirname)
        except XMLSyntaxError:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: XMLSyntaxError', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            metadata = {}
                
        os.remove(f)
        
        """
        Update the image table with the success result.
        """
        obj = {}
        obj['uri'] = '/%s?%s' % (self.viewer, urls)
        obj['RID'] = rid
        obj['Processing_Status'] = 'success'
        obj['Original_File_MD5'] = md5
        columns = ['uri', 'Processing_Status', 'Original_File_MD5']
        
        for col in self.metadata:
            if col in metadata and metadata[col] != None:
                columns.append(col)
                obj[col] = metadata[col]
                
        self.updateAttributes(schema,
                              table,
                              rid,
                              columns,
                              obj,
                              status)
        
        self.logger.debug('SUCCEEDED created the tiles directory for the file "%s".' % (filename)) 
        
        self.logger.debug('Ended CZI Processing for the %s:%s table.' % (schema, table)) 
        
    """
    Extract the file from hatrac
    """
    def getHatracFile(self, filename, file_url):
        try:
            hatracFile = '%s/%s' % (self.data_scratch, filename)
            self.store.get_obj(file_url, destfilename=hatracFile)
            self.logger.debug('File "%s", %d bytes.' % (hatracFile, os.stat(hatracFile).st_size)) 
            return hatracFile
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: write thumbnail ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            return None

    """
    Generate the thumbnail
    """
    def writeThumbnailImage(self, schema, filename, year, md5):
        try:
            scanDir='%s/%s/%s/%s' % (self.dzi, schema, year, md5)
            channels = []
            for channel in os.listdir(scanDir):
                if os.path.isdir('%s%s%s' % (scanDir, os.sep, channel)):
                   channels.append( channel)
            outdir = '%s/%s/%s' % (self.thumbnails, urlquote(schema), year)
            if not os.path.exists(outdir):
                os.makedirs(outdir)
            shutil.copyfile('%s/%s/%s/%s/%s/0/0_0.jpg' % (self.dzi, urlquote(schema), year, md5, channels[0]), '%s/%s.jpg' % (outdir, md5))
            thumbnail_url = '/thumbnails/%s/%s/%s.jpg' % (urlquote(schema), urlquote(year), urlquote(md5))
            return thumbnail_url
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: write thumbnail ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            os.remove(filename)
            return None
            
    """
    Get the pyramid URL
    """
    def getPyramidURL(self, schema, filename, year, md5, waterMark):
        try:
            scanDir='%s/%s/%s/%s' % (self.dzi, schema, year, md5)
            channels = []
            for channel in os.listdir(scanDir):
                if os.path.isdir('%s%s%s' % (scanDir, os.sep, channel)):
                   channels.append( channel)
            urls = []
            for channel in channels:
                urls.append('url=/data/%s/%s/%s/%s/ImageProperties.xml%s' % (schema, year, md5, channel, waterMark))
            return '&'.join(urls)
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: Get Pyramid URL ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            os.remove(filename)
            return None
            
    """
    Convert the input file to DZI
    """
    def convert2dzi(self, filename, outdir):
        try:
            currentDirectory=os.getcwd()
            os.chdir(self.dzi)
            args = [self.czi2dzi, filename, outdir]
            p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdoutdata, stderrdata = p.communicate()
            returncode = p.returncode
            os.chdir(currentDirectory)
            
            if returncode != 0:
                self.logger.error('Can not convert czi to dzi for file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (filename, stdoutdata, stderrdata)) 
                self.sendMail('FAILURE Tiles', 'Can not convert czi to dzi for file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (filename, stdoutdata, stderrdata))
                os.remove(filename)
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got unexpected exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: czi2dzi ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            os.chdir(currentDirectory)
            self.logger.error('Can not generate pyramidal tiles for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (filename, stdoutdata, stderrdata)) 
            self.sendMail('FAILURE Tiles', 'Can not generate pyramidal tiles for the file "%s".\nstdoutdata: %s\nstderrdata: %s\n' % (filename, stdoutdata, stderrdata))
            returncode = 1
            
        return returncode
            
        
    """
    Update the ermrest attributes
    """
    def updateAttributes (self, schema, table, rid, columns, row, status):
        """
        Update the ermrest attributes with the row values.
        """
        try:
            columns = ','.join([urlquote(col) for col in columns])
            url = '/attributegroup/%s:%s/RID;%s' % (urlquote(schema), urlquote(table), columns)
            get_claimable_url = '/entity/%s:%s/RID=%s/Processing_Status=%s' % (urlquote(schema), urlquote(table), urlquote(rid), urlquote(status))
            put_claim_url = url
            claim_input_data = lambda item: row
            idle_etag = None
            idle_etag, batch = self.catalog.state_change_once(
                get_claimable_url,
                put_claim_url,
                claim_input_data,
                idle_etag
            )
            if len(batch) == 1:
                self.logger.debug('Update through state_change_once succeeded');
            else:
                self.logger.debug('Update through state_change_once failed, returned %d rows' % len(batch))
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: reportFailure ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            
    """
    Update the ermrest attributes
    """
    def updateAttributesFromRelatedTable (self, path, rid, columns, row):
        """
        Update the ermrest attributes with the row values.
        """
        try:
            columns = ','.join([urlquote(col) for col in columns])
            url = '/attributegroup/%s/RID;%s' % (path, columns)
            resp = self.catalog.put(
                url,
                json=[row]
            )
            resp.raise_for_status()
            self.logger.debug('SUCCEEDED updated the table "%s" for the RID "%s"  with "%s".' % (path, rid, json.dumps(row, indent=4))) 
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: reportFailure ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
            
            
    """
    Insert a row in a table
    """
    def createEntity (self, path, row):
        """
        Insert the row in the table.
        """
        try:
            url = '/entity/%s' % (path)
            resp = self.catalog.post(
                url,
                json=[row]
            )
            resp.raise_for_status()
            self.logger.debug('SUCCEEDED created in the table "%s" the entry "%s".' % (path, json.dumps(row, indent=4))) 
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: reportFailure ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))

    """
    Check if an entry exist in the table
    Return the RID if it exists, and None otherwise
    """
    def getRID (self, path, predicate):
        """
        Get the RID of the row.
        """
        try:
            RID = None
            url = '/entity/%s/%s' % (path, predicate)
            resp = self.catalog.get(url)
            resp.raise_for_status()
            rows = resp.json()
            if len(rows) == 1:
                RID = rows[0]['RID']
            self.logger.debug('RID for the url = "%s" is "%s".' % (url, RID)) 
        except:
            et, ev, tb = sys.exc_info()
            self.logger.error('got exception "%s"' % str(ev))
            self.logger.error('%s' % ''.join(traceback.format_exception(et, ev, tb)))
            self.sendMail('FAILURE Tiles: reportFailure ERROR', '%s\n' % ''.join(traceback.format_exception(et, ev, tb)))
        
        return RID

    """
    Get the hexa md5 checksum of the file.
    """
    def md5hex(self, fpath):
        h = hashlib.md5()
        try:
            f = open(fpath, 'rb')
            try:
                b = f.read(4096)
                while b:
                    h.update(b)
                    b = f.read(4096)
                return h.hexdigest()
            finally:
                f.close()
        except:
            return None

